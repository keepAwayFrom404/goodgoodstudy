# 2019.07.12 开启高级程序设计第三版学习之路（每日必编程）

## 第一章简介 js

### 07.13

1. js 发展历史

### 07.14

2. 文档对象模型 DOM 主要用于操作 DOM 树；BOM 浏览器对象模型，存在 window，navigator，location，screen 还有 XMLHttpRequest 对象等；浏览器的支持主要指对 es 和 dom 的支持
3. 小结
   （1）es 提供核心的语言功能
   （2）DOM：提供访问和操作网页内容的方法和接口
   （3）BOM：提供与浏览器交互的方法和接口
   （4）五大主要浏览器：IE，Firefox，Chrome，Safari，Opera

## 第二章在 html 中使用 js

1. 脚本引入内容
   （1）script 脚本的 async 属性表示应该立即下载脚本，不然按照文档中的顺序加载，定义 async 的脚本不一定按顺序执行，所以确保两者之间互不依赖非常重要，异步脚本一定在 load 事件之前，但与 DOMCotentLoaded 的先后顺序不确定。
   （2）defer 属性只是用外部脚本且多个延迟脚本并不一定会按照顺序执行，也不一定会在 DOMCotentLoaded 之前执行，所以最好只包含一个延迟脚本。
2. 小结
   （1）不包含 defer 和 async 的情况下 js 代码是顺序解析的
   （2）noscript 标签可以在没开启 js 情况下显示 html 内容

## 基本概念

### 07.15: 第三章看完数据类型与一些操作符，看到 3.6 语句小节

1. 数据类型
   （1）undefined：定义未初始化变量会默认赋值 undefined，未定义变量的 typeof 运算也等于 undefined
   （2）null：null 值表示一个空对象指针，null == undefined，undefined 派生自 null
   （3）number：保存浮点数的空间是整数的两倍，0.1+0.2 不等于 0.3（舍入误差跟 IEEE754 数值格式有关）；isFinite 可以判断数值是否超出表示范围; 涉及 NaN 的操作都返回 NaN，NaN 与任何值都不相等，isNaN 任何不能转换为数值的值都会返回 true，在判断对象时会先调用对象的 valueOf 方法不能转数值再调用 toString 方法
   （4）number 类型方法：一元+操作运算符与 Number 函数转换方式想同，undefined 返回 NaN，字符串 0 前导忽略，null 返回 0，空字符返回 0，对象 valueOf->toString；parseInt 数字开头转数字进制可转，空字符串 NaN，第二个参数指示进制；parseFloat 只解析十进制，第二个小数点无效，省略前导 0，没有小数点返回整数，十六进制转为 0
   （5）字符串：一些基本的转义序列: \n 换行，\t 制表，\b 空格，\\斜杆，\'单引号，\"双引号
   （6）字符串：字符串的修改会销毁原来字符串再新建一个字符串, 转字符串 toString，null 和 undefined 没有这个方法；String 能兼容 null 和 undefined 的字符串化
   （7）递增递减操作符：操作符在运用在对象上时会先调用 valueOf 或者 toString 方法将对象转换为可操作的值，
   （8）与操作符：第一个对象，返回第二个操作数；第二个操作数是对象只有当第一个操作数的结果返回 true 的情况才会返回该对象,否则返回第一个操作数;两个对象，返回第二个操作数；一个操作数是 null 返回 null；一个 NaN 返回 NaN；一个 undefined 返回 undefined；逻辑与操作属于短路操作，如果第一个值能够决定结果就不会再对第二个操作数求值
   （9）或操作符：有一个操作数不为布尔值则不一定返回布尔值；第一个值为对象直接返回第一个值；第一个求值为 false，返回第二个值；两个对象返回第一个；两个 null 返回 null；两个 NaN 返回 NaN；两个 undefined 返回 undefined；也是短路操作，第一个值为 true 就不计算第二个值了。
   （10）乘法：Infinity\*0=NaN；除法 Infinity/Infinity=NaN，0/0=NaN；
   （11）加法：Infinity+-Infinity=NaN；只有一个字符串会将另一个转为字符串再拼接；一个操作数是对象、数值或布尔值调用 toString 方法，null 和 undefeated 调用 String 转为字符串
   （12）减法：Infinity-Infinity=NaN；-Infinity--Infinity=NaN;如果有一个操作数是字符串、布尔值、null 或者 undefined，则先在后台调用 Number 函数将其转为数值，然后再进行减法计算；如果有一个值是对象则调用对象的 valueOf 方法没有则调用 toString
   （13）比较运算：两个字符串的比较字符编码的位置，区分大小写;NaN 做比较都 false
   （14）相等与不相等：会进行类型转换，有一个布尔转为数值再比较;一个字符串一个数值，字符串转为数值再比较；一个对象一个不是对象，valueOf 转换之后再比较；null==undefined；一个 NaN 相等返回 false 不等返回 true，NaN != NaN；两个对象比较是否同一个对象，都指向同一个对象则为 true，否则为 false；null == 0 为 false,但是 null 转数值为 0
   （15）全等与不全等：比较之前不会进行转换

### 07.16:

2. 语句
   （1）for in 枚举对象属性;
   （2）label：可以在代码中添加标签，等待后期由 break 或者 continue 调用
   （3）break：跳出循环执行循环之后的语句
   （4）continue：跳过一便循环
   （5）with：可用来绑定对象创建新的作用域，with 中的赋值会先到局部环境寻找，未找到则以绑定的对象属性赋值，严格模式下禁用 with（会导致性能下降，调试困难）
   （5）switch：可使用任何数据类型，case 的值可以为变量，甚至是表达式，在比较时使用的是全等运算符
3. 函数
   （1）严格模式下，重写 arguments 的值会导致语法错误（代码将不会执行）
   （2）所有的参数传递都是值，不能通过引用传递参数
   （3）判断传入参数的个数进行不同反应可以模仿方法的重载
4. 小结

## 第四章 变量，作用域和内存

### 07.17：基本类型和引用类型的值

1.

（1）基本类型：赋值只是拷贝了一份副本，赋值之后互不影响
（2）引用类型：值的复制实际是复制了一份指针，最终值指向同一个内存地址，所以改变会互相影响
（3）函数参数：是值传递而不是引用传递，可以把函数参数想象成局部变量，改写引用用类型在向参数传值时，会把这个值的引用地址复制一份给到局部变量，因此这个局部变量的变化会反应到函数外部，在函数内部重写引用类型的形参，这个变量引用的就是一个局部对象了，而这个局部对象会在函数执行完后销毁。
（4）类型检测：instanceof

### 07.18: 执行环境和作用域

2.

（1）变量的访问规则是从作用域链的最里层到最外层查询的

### 07.19: 变量查找与垃圾收集

3.

（1）try catch 和 with 可以延长作用域链，但是谨慎使用，会影响性能
（2）初始化变量时没有声明会自动添加到全局环境
（3）垃圾回收大多使用标记清除法，标记变量状态，在离开环境之后就清除掉；使用引用计数法会存在循环引用，一直占用内存的情况，在循环引用结束之后可以把属性设置为 null 释放内存

4. 小结
   （1）基本类型占据固定大小的空间，保存在栈内存中；引用类型的值是对象，保存在堆内存中
   （2）instanceof 区分引用类型的类型
   （3）离开作用域的值被自动标记为可以回收，在垃圾收集期间被删除；及时释放不使用的全局对象以及全局对象的属性以及循环引用变量的引用

## 第五章 引用类型

1. Object 类型
   （1）对象属性可以是字符串，对于数字会自动转为字符串
   （2）使用方括号访问属性时应该将属性的字符串形式放入，不使用字符串时就相当于变量访问；建议使用点访问
2. Array 类型
   （1）数组和对象一样有字面量创建形式
   （2）默认情况数组的 toString、valueOf 与 toLocalString 方法都会以逗号分割的字符串的形式返回数组项；若数组项为 null 或者 undefined 会返回空字符串
   （3）栈方法：push：接收任意多的参数加到字符串末尾，返回修改后的数组的长度；pop：移除最后一项并返回最后一项；
   （4）队列方法：shift：移除数组第一项并返回该项；unshift：向数组首部添加若干项并返回新数组长度
   （5）重排序方法：reverse：反转数组；sort：灵活排序，比较的是字符串，先调用 toString 转型，可以接收一个比较函数，函数两个值，第一个值应该位于前面返回负数，相等返回 0，第一个应该位于后面返回正数；两个方法都返回排序之后的数组
   （6）操作方法：concat：基于当前数组创建一个新数组，首先创建当前数组的副本，然后将接收到的参数添加到数组的末尾，最后返回新构建的数组，不传值则复制当前数组并返回副本；slice：基于当前数组一或多项创建一个新数组，两个参数不包含结束位置项，不会影响原数组，参数有负数，则用数组长度加上该数来确定相对位置，结束位置小于起始位置返回空数组；splice：主要用途是向数组中部插入项，splice（start，num）删除从指定位置开始的 num 项，但如果提供给了第三个参数，表示把前面的删除然后将第三个参数之后的项插到删除位置,没删除则直接在 start 插入，splice 方法始终返回一个数组，包含从元数组删除的项，没有删除则返回空数组;indexOf 判断数组是否包含某项返回位置，不包含返回-1，相等使用的时全等运算符，所以数组元素是对象时要注意,第二个参数是查询的开始位置；与 lastIndexOf 差别在于 lastIndexOf 是从末尾开始查询的；

### 07.20

（7）迭代方法：every：每一项都执行函数，全部返回 true 则返回 true；filter：：每一项都执行函数，返回函数会返回 true 的项组成的数组；forEach：：每一项都执行函数，没有返回值，不能 return；map：：每一项都执行函数，返回每次函数调用的结果组成的数组（return 的结果）；some：：每一项都执行函数，有一项返回 true 则返回 true；以上方法都不会修改原数组。
（8）归并方法：reduce：从第一项开始到最后一项；reduceRight：与 reduce 一样，只是从末尾开始；且两个方法都会迭代数组的每一项，然后构建一个最终返回值，都接收四个参数：前一个值、当前值、项的索引和数组对象，这个函数的任何返回值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，第一个参数是数组第一项，第二个参数是数组第二项。

3. Date 类型

### 07.21

（1）1970 年开始到现在的时间戳
（2）方法：

- getTime() 返回时间戳
- getFullYear() 返回四位数的年份
- getMonth() 返回 0 开始的月份，记得加 1
- getDate() 返回日期中的天数，1-31
- getDay() 返回日期中星期几，0 表示星期日
- getHours() 返回小时数，0-23，记得加 1
- getMinutes() 返回分钟数 0-59
- getSeconds() 返回日期的秒数 0-59
- getMilliseconds() 返回日期的毫秒数
- getTimezoneOffset() 返回本地时间与 UTC 时间相差的分钟数
- 超过最大值则前一位加 1

4. RegExp 类型
   （1）匹配模式（标记（flags））

- g：全局模式，模式将应用于所有字符串而不是发现第一个匹配项时立即停止
- i：不区分大小写：确定匹配项时忽略模式与字符串的大小写
- m：多行模式：到达一行文末还会继续寻找下一行是否存在与模式匹配的项
  （2）元字符（需要转义的）\
- ([{\^$|)?*+.]}
  （3）正则构造函数两个参数都是字符串，且需要进行双重转义
  （4）实例属性：
- global：布尔值，表示是否设置了 g 标志
- ignoreCase：布尔值，表示是否设置了 i 标志
- lastIndex：整数，开始搜索下一个匹配项的字符位置，从 0 开始
- multiline：是否设置 m 标志
- source：正则表达式的字符串表示，按照字面量形式返回
  （5）实例方法：
- exec：捕获组，一个参数，要应用模式的字符串；返回包含第一个匹配项信息的数组，没有匹配项返回 null；返回的数组额外包含 index 和 input 属性，index 表示匹配项在字符串中的位置；input 表示正则表达式的字符串；数组中第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串，没有捕获组则数组只包含一项
- test：字符串参数，参数与模式匹配返回 true
  （6）构造函数属性：
- input：最近一次要匹配的字符串
- lastMatch：最近一次的匹配项
- lastParen：最近一次匹配的捕获组
- leftContext：input 字符串 lastMatch 之前的文本
- multiline：布尔值，表示是否所有模式都使用多行模式
- rightContext：input 字符串 lastMatch 之后的文本
- 使用以上属性可以从 exec 和 test 获取更具体的信息
- $1-$n 顺序填充捕获组 1-n

5. Function 类型
   （1）函数名是指向函数对象的指针，不会与某个函数绑定
   （2）函数声明存在变量提升，函数表达式则没有
   （3）函数内部属性：

- arguments：主要保存函数参数，它有一个 callee 属性，是一个指针，指向拥有这个 arguments 对象的函数
- this：引用的是函数据以执行的环境对象
- caller：保存调用当前函数的函数的引用，调用栈，严格模式不能赋值
  （4）函数的属性和方法
- length：函数希望接收参数的个数
- prototype：不可枚举，for in 无法发现，apply：两个参数，一个是在其中运行函数的作用域，另一个是参数数组，可是 Array 实例或者 arguments 对象；call：第二个参数开始接收其它参数，参数必须逐个列举；两个方法都是用来绑定 this，扩充函数赖以运行的作用域，且对象和方法不需要任何耦合关系；bind：会创建一个函数的实例，this 值会绑定到传给 bind 函数的值

6. 基础包装类型
   （1）引用类型和基本包装类型主要的区别在于对象的生存期，new 创建的引用类型实例在执行流离开之前都存在内存中，而自动创建的包装类型对象只存在一行代码的一瞬间然后立即销毁，所以不能在运行时为基本类型值添加属性和方法
   （2）基本包装类型实例 typeof 返回 object，而且所有包装类型的对象都会转变成 true
   （3）Object 构造函数会像工厂函数一样，根据传入值的类型返回相应基本包装类型的实例
   6.1 Boolean 类型
   （1）new 的实例对象做逻辑操作返回 true 而不是求的的值
   6.2 Number 类型

- toFixed：显示几位小数
- toExponential： 指数表示法
- toPrecision：参数为数值的所有数字的位数（不包含指数部分）
  6.3 String 类型
  （1）字符方法：
- charAt 和 charCodeAt：单字符字符串的形式返回给定位置的那个字符;字符编码
- 使用方括号访问位置
  （2）操作方法：
- concat：将一个或多个字符串拼接起来，返回拼接得到的新的字符串
- slice、substring、substr：基于字符串创建新字符串的方法，前两个参数为开始，结束位置，第三个的第二个参数为个数，都不会修改到原始字符串
  （3）字符串位置方法：
- indexOf：搜索给定的子字符串，返回位置，没有返回-1
- lastIndexOf：反向查找
  （4）trim
- 创建一个字符串副本，删除前置和后缀的所有空格，然后返回结果
  （5）大小写转换
- toLowerCase：转小写
- toUpperCase：转大写
  （6）模式匹配方法：
- match：类似调用 exec，接收一个正则，返回一个数组
- search：参数与 match 相同，返回第一个匹配的索引，没有则返回-1，始终从开头查找
- replace：第一个参数为正则或者字符串，如果是字符串则只会替换第一个子字符串，想全部替换必须正则且 g 标志；第二个参数也可以是函数，函数可接收三个参数：模式匹配项、模式匹配项在字符串中的位置和原始字符串，应该返回字符串
- split：基于指定的分隔符将字符串分割成多个子字符串，并将结果放在一个数组中，分隔符可以是字符也可以是正则，第二个参数可选指定数组大小，以保证返回的数组不会超过既定的大小
  （7）localeCompare 方法：
- 比较字符串，返回：参数在字母表排在后面返回负数，相等返回 0，前面返回正数
  （8）fromCharCode：
- 接收一个或多个字符编码，然后将他们转成字符串

7. 单体内置对象：在程序执行前就存在了
   7.1 Global 对象
   （1）不属于任何其它对象的属性和方法就是它的属性和方法
   （2）方法：

- URI 编码方法：encodeURI：主要用于整个 URI，不会对本身的特殊字符编码，比如冒号、正斜杠、问号和井字号，除空格之外，其他不动空格换成%20；encodeURIComponent：部分编码，会对发现的任何非标准字符编码，对应 decodeURI 与 decodeURIComponent
- eval：就像一个完整的 ECMAscript 解析器，只接收一个参数，即要执行的 ECMAScript 字符串;在 eval 创建的所有变量和函数都不会提升，因为在解析代码的时候，它们被包含在字符串中，它们只在 eval 执行的时候创建；严格模式下访问不到 eval 内的任何变量和函数，有代码注入风险
  （3）属性：
- undefined、NaN、Infinity、对象的所有构造函数、Date、Error，禁止给 undefined、NaN、Infinity 赋值
  （4）window 对象：
- 浏览器当中 window 包含了 globel 对象
  7.2 Math 对象
  （1）属性：
- PI：你懂的
  （2）min 和 max
- 确定最大最小值，可接收任意多数值参数
  （3）舍入方法：
- ceil：向上舍入
- floor：向下舍入
- round：标准舍入，四舍五入
  （4）random
- 返回大于等于 0 小于 1 的一个随机数，值=Math.floor(Math.random()\*可能值的总数+第一个可能的值)
  （5）其它方法：
- abs：绝对值
- pow：次方，第一个参数为底数，第二个参数为指数
- sqrt：平方根

8. 小结

## 第五章 面向对象程序设计

### 07.23

1. 理解对象
   （1）数据属性：包含一个数据值的位置，可以读取写入值，具有四个描述其行为的特性

- Configurable：是否可以通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，可配置，设置不可配置则不能再设置回可配置，此时，使用 defineproperty 修改除 writable 之外的属性都报错
- Enumerable：能否通过 for in 返回属性，可枚举
- Writable：能否修改的属性，可修改
- Value：包含属性的数据值，读取属性的值的时候，从这个位置读取，写入也是在这个位置，默认值为 undefined
- Object.defineProperty：修改默认属性，接收三个参数：属性所在的对象、属性的名字、一个描述符对象,不指定数据属性默认为 false
  （2）访问器属性：
- Configurable：是否可以通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性
- Enumerable：能否通过 for in 返回属性，可枚举
- Get：读取属性时调用的函数，默认 undefined
- Set：写入属性时调用的函数，默认 undefined
- 访问器属性不能直接定义，必须使用 Object.defineProperty
  （3）Object.defineProperties 可一次性定义
  （4）Object.getOwnPropertyDescriptor：
- 接收两个参数：属性所在的对象和要读取的描述符的属性名称，返回一个属性描述对象

### 07.24

2. 创建对象（设计模式）
   （1）工厂模式：抽象了创建具体对象的过程；无法知道一个对象的类型（对象识别问题）
   （2）构造函数模式：

- 构造器函数始终以大写字母开头
- 创建新实例必须使用 new 操作符，new 实际经过了四个步骤：创建一个新的对象；将构造函数的作用域赋给新对象（this 指向新对象）；执行构造函数代码（为新对象添加属性）；返回新对象。
- new 的实例对象都有一个 constructor 属性，指向构造函数，最初用来标志对象类型
- 当作普通函数调用会挂载到全局对象上
- 缺点：每个方法都要在每个实例上重新创建一遍，方法放在全局又缺失了封装性
  （3）原型模式：
- 我们创建的每一个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向函数原型对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，所有实例可共享它所包含的属性和方法
- 原型对象：新建一个 Person 构造函数，该构造函数会自动获得一个 prototype 属性，指向该构造函数的原型对象（Person prototype），默认情况下，原型对象上会自动获得一个 constructor 属性，指向 prototype 属性所在函数的指针（Person 函数），且原型对象包含后面添加的属性和方法，之后通过 Person 构建的实例对象都会包含一个内部属性（[[prototype]]不可访问）可通过**proto**访问，指向构造函数的原型对象（Person.prototype），所以实例与构造函数之间没有直接的关系；虽然在所有的实现中都无法找到[[prototype]]，但可以通过 isPrototypeOf 来确定对象之间是否存在这种关系。
- Object.getPrototypeOf：返回[[prototype]]的值（构造函数的原型对象）
- 在实例中添加与原型同名的属性或者方法会屏蔽原型的属性或者方法而并不会修改到原型，使用 delete 可以删除该属性从而重新获取原型上的该属性或方法
- hasOwnProperty：检测给定的属性是存在于实例还是原型对象上（这个方法是从 Object 上继承来的）
- Object.getOwnPropertyDescriptor 只能用于实例属性，要获得原型属性的描述，到原型对象上调用该方法
- Object.keys：返回对象上所有的可枚举实例属性
- Object.getOwnPropertyNames：得到所有的实例属性，无论是否可以枚举
- 使用对象字面量的形式创建原型的属性会导致 constructor 属性不再指向构造函数，此时 constructor 指向 Object，instanceof 还能返回正确的结果，但是 constructor 已经无法判断对象的类型了
- 重写原型对象会切断之前创建的实例与原型对象之间的联系
- 原型对象的缺点：所有实例在默认情况下将获得相同的属性，对于包含引用类型的属性，问题比较突出，指针指向的是同一个对象地址，修改会互相影响
  （4）组合使用构造函数模式和原型模式
- 创建自定义类型最常见的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性；这种模式还支持向构造函数传递参数，
  （5）动态原型模式（没看懂有啥用）
- 把所有信息封装到构造函数中，而在构造函数中初始化原型（仅在必要的情况下），if 检查必要的属性和方法，
- 不能使用对象字面量来写原型，会切断现有实例与原型之间的联系
  （6）寄生构造函数模式
- 基本思想：创建一个函数，该函数的作用仅仅是封装对象的代码，然后返回新创建的对象
- 返回的对象和构造函数与构造函数的原型之间没有关系，构造函数返回的对象和在构造函数外部创建的对象没有差别，不能使用 instanceof 确定对象类型，在可以使用其它模式的情况下不要使用这种模式
  （7）稳妥构造函数模式
- 稳妥对象指的是没有公共属性，而且其方法也不引用 this 的对象。
- 与寄生构造函数区别：新创建的对象实例方法不引用 this，不使用 new 操作符调用构造函数
- 不能使用 instanceof 确定对象类型

3. 继承：只能实现实现继承，且是依靠原型链实现的
   （1）原型链

- 基本思想：利用原型将一个引用类型继承另一个引用类型的属性和方法
- 原型继承之后实例的 constructor 属性指向 SuperType，因为 SubType.prototype 中的 constructor 被重写的原因（实际是 SubType 的原型指向了另一个对象--SuperType 的原型，而这个原型的 constructor 又指向了 SuperType 构造函数）
- 所有的引用类型都继承了 Object，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针指向 Object.prototype，这也是自定义类型都继承了 toString、valueOf 等默认方法的根本原因
- 确定实例与原型之间的关系，instanceof 测试实例与原型链中出现过的构造函数就会返回 true；isPrototypeOf，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此也会返回 true
- 给原型添加方法一定放在替换原型的语句之后，不能使用对象字面量创建原型方法，会重写原型链
- 存在的问题：主要问题存在与含有引用类型的原型；在创建子类型的实例时不能向超类型的构造函数传递参数（没有办法在不影响所有对象实例的情况下，给超类型传递参数），因此实践中很少单独使用原型链
  （2）借用构造函数
- 基本思想：在子类型构造函数中调用超类型构造函数，使用动态 this 绑定，初始化超类型内的属性
- 函数复用无从谈起，而且在超类型原型中定义的方法在子类型中是不可见的，所以所有类型都要使用构造函数模式，所以该技术也很少使用
  （3）组合继承（伪金典继承）
- 使用原型链的实现对原型属性和方法的继承，而借用构造函数实现对实例属性的继承
- 组合继承结合原型链和构造函数继承的优点，是最常用的继承模式
  （4）原型式继承
- 借助原型可以基于已有的对象创建新对象，同时不必因此创建自定义类型。
- Object.create：规范了原型式继承，接收两个参数，一个用作新对象原型的对象，一个为新对象定义额外属性的对象，传入一个参数与 object 方法行为相同，第二个参数定义的属性会覆盖原型上的同名属性
- 在只是想让一个对象与另一个对象类似的情况下，可使用原型式继承，包含引用类型的属性始终都会共享相应的值，就像原型模式一样。
  （5）寄生式继承
- 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象，最后再像真的是它做了所有的工作一样返回对象
- 不能做到函数复用而降低效率
  （6）寄生组合式继承
- 组合继承必须两次调用超类型的构造函数，一次在创建子类型原型的时候，一次在子类型构造函数内部
- 借用构造函数来继承属性，借助原型链的混成形式来继承方法
- 基本思路：不必为了指定子类型的原型而调用超类型的构造函数，所需要的只是超类型原型的一个副本，可使用寄生式继承继承超类型的原型，然后将结果指定给子类型的原型
- 只调用一次超类型构造函数，避免了在子类型的原型上创建不必要的、多余的属性，同事原型链包保持不变，是引用类型最理想的继承范式

4. 小结
   （1）ECMAscript 支持 OO 编程，但是不使用接口或者类，对象可以在创建过程中增强
