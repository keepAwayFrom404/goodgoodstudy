特点：

1. 在一轮 eventloop 中多次修改 dom，只有最后一次会进行绘制
2. 渲染更新会在 eventloop 中的宏任务和微任务完成后进行，但不是每轮都会更新渲染，取决于是否修改 dom 和浏览器觉得是否必要立即将新状态呈现给用户；如果在一帧的时间内多次修改 dom，浏览器可能会把变动积攒起来，只进行一次绘制。
3. 如果想每轮循环都呈现变动，可以使用 requestAnimationFrame
4. js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。
5. setTimeout 传 0 秒，当主线程为空，至少等待 4ms 才会执行而不是立即执行

使用场景

1. 对于一些简单的场景，同步完全可以胜任，如果得对 dom 反复修改或者进行大量计算时，使用异步可以作为缓冲，优化性能。

流程：

1. 判断同步任务还是异步任务，同步任务进入主线程，异步进入 Event Table 注册函数；
2. 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue；
3. 主线程的任务执行完毕为空，回去 Event Queue 读取对应的函数进入主线程执行；
4. 不断重复上诉过程就是 Event Loop（事件循环）
