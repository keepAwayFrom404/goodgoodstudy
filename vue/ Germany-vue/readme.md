# 第二节 Vue 和 DOM 交互的基本方法

1. methods 当中的函数要返回一个可以转换为字符串的值才能在 html 模版里调用
2. 实例中的 this 可以访问 vue 实例当中定义的所有属性和方法
3. 在属性中使用双括号的模版语法双括号会被编码而无法解析，所以需要使用 v-bind
4. 指令是 vue 提供的一些指示
5. v-once 作用于 html 标签，使得内部的模版只会渲染一次
6. v-html 要谨慎使用，因为不知道用户提交的是什么内容，容易 XSS 攻击，只用来绑定自己生成的或者完全可靠的代码,或者拿到值之后进行输入检查
7. 事件 v-on 缩写后面的名字实际是传递给监听器的事件名参数
8. vue 事件会自动生成一个事件对象,可以通过第一个参数获取,当传递了其它参数可以通过传递\$event（不可改变）获得事件对象
9. 事件的 stop 修饰符可以阻止事件冒泡,prevent 阻止默认事件
10. keyup 键盘事件加上按键修饰符，可以多个
11. v-model 的本质是：（1）v-bind 绑定实例里面的值；（2）绑定输入事件当值变化时重新赋值
12. 计算属性里面所有的值都可以像 data 里面的值一样使用，使用计算属性只有内部的值变化才会重新计算，而使用 methods 每次点击都会触发模版语法中的事件
13. 计算属性只能执行同步代码，不能处理异步情况，watch 可以用来处理异步的情况
14. 回调函数不使用箭头函数 this 指向 window
15. class 绑定一个对象，key 为绑定的类名，如果类名包含中划线等字符需要使用单引号包起来，value 为一个布尔值，决定 key 的类名是否需要绑定；绑定多个类名可以使用计算属性 return 需要绑定的类对象；可以使用数组形式给 class 绑定多个表示类名的属性或者类名属性加混合对象来添加多个类名
16. style 绑定的也是一个 css 属性对象，也可以使用数组绑定混合样式
17. 小结：
    （1）最后一个题目没有自己的思路就直接开始乱写
    （2）取名字没有自己的规范，不够通熟易懂
    （3）代码偷懒

# 第三节 使用条件和列表渲染

1. template 标签在 html 中不会渲染，使用条件渲染可以将元素组合起来且不产生副作用
2. v-if 表示添加或者移除节点，v-show 是 css 隐藏（display：none），还存在与 dom 中,
3. v-for 除了可以遍历数组还可以遍历对象，index 为对象的 key 值而不是下标了，遍历对象下标在第三个参数

# 第五章 理解 vue 实例

1. 一个文件中可以共存多个 vue 实例，且他们之间互不影响，各自管理内部的属性和方法
2. vue 实例代理了内部属性内部的所有属性和方法，所以可以通过实例直接访问它们
3. 在实例的属性中有一个\$data 属性，等于 data 内部的属性对象
4. \$refs 不是响应式的，直接操作 dom 可能会被覆盖
5. \$mount 在没提供 el 时会创建一个未挂载的实例，文档将会被渲染为文档之外的元素，并且必须使用原生 DOM API 将它插入文档，返回实例本身，可以链式调用其他实例方法
6. 普通的 vue 实例不能当作组件的原因在于它只替换一个匹配到的元素，所以要注册组件
7. beforeCreate 生命周期在 new 实例创建之前执行，vue 会初始化构造方法传递的数据和事件，才创建 vue 实例；然后执行 created，之后 vue 会编译模版，根据 el 属性或者\$mount 方法从 HTML 代码内获取模版；beforeMount：挂载要渲染的模版之前调用，模版即将写入 DOM；然后将模版写入 DOM 触发 mounted

# 第六章 vue 命令进入真实开发

1. vue 文件编译后成为 js 可以插入到页面生成 dom

# 第八章 组件间通信

1. 父子组件传递对象或者数组等引用类型的数据时，实际传递的时指向内存地址的指针，改变会互相影响
2. \$emit 可以在子组件自定义事件，然后在父组件监听该事件并进行相应操作
3. event bus 是用来监听事件和传递数据的对象
4. 事件总线 eventbus 对象的注册应该在创建 vue 实例之前

# 第九章 深入组件

1. slot 的样式作用域是使用的地方而不是写的地方，而代码作用域是写的地方；样式在子组件设置，其他东西在在父组件处理
2. v-slot 指令只能使用在 template 元素上，而之前的 slot 可以用于任意元素
3. 绑定在 slot 上的特性被称为插槽 prop，可以给 v-slot 带一个值来定义我们提供插槽 prop 的名字；当只有默认插槽的时候 v-slot 可以用在组件上，不能混用
4. 作用域插槽的工作原理是将你的插槽内容包括在传入一个参数的函数当中，可以使用 v-slot：【动态名】来定义动态插槽名
5. 动态组件使用 component 标签 is 标识，里面可以插入内容会覆盖组件内容；动态组件之间切换会销毁重新创建；使用 keep-alive 可以保活
6. deactivated 在一个组件里载入另一个动态组件时调用（离开时）
7. activated：载入动态组件时调用

# 第十一章 用户表单输入处理

1. 给 v-model 绑定.lazy 修饰符会改变监听 input 而实际监听 change 事件；.trim 去除首尾空格；.number 将输入转成数字
2. 保留 textarea 文本的换行符可以使用样式 white-space：pre 保留
3. 给多个 input 类型为 checkbox 的元素绑定同一个变量，vue 会将它们自动整合到一个数组中；给多个 type 为 radio 绑定同一个值，会讲选中的值存入变量（存入的是 value 属性）
4. option 的 selected 属性可以绑定默认选项值（传入布尔值）；会被 v-model 绑定的默认值覆盖
5. prevent 修饰符可以阻止默认的 submit 事件
6. 不要再子组件修改父组件传递的 props 属性，会报错

# 第十二章 使用和创建指令

1. 指令下有五个钩子：

- bind：一旦指令完成绑定触发，三个参数：el 绑定的那个元素可以用来操作 dom；binding 是使用指令时的配置（参数。修饰符等）；vnode 虚拟 dom 中的节点（用的相对较少）
- inserted：成功插入父节点（仅保存父节点存在，不一定插入成功），但是可以直接操作，操作都会在插入之后表现出来，与 bind 参数一致
- update：一旦组件更新即调用，子组件尚未更新，多了一个 oldVnode 参数
- componentUpdate：一旦组件更新完，包括子组件
- unbind：指令移除时调用
- bind 和 update 是最常用的两个钩子

# 第十三章 过滤器和混入

1. filter 可以在通过 Vue.filter 全局注册也可以使用组件的 filters 属性注册
2. 计算属性的性能优于过滤器
3. 混入的的内容只有在引用的实例中不存在才会添加，生命周期都会执行且混入对象的优先于组件内部的执行
4. 组件混入可以使用 mixins 属性，全局混入一般在开发插件使用，身生产使用少使用 Vue.mixin，且全局混入会在所有 vue 实例执行包括 new Vue 中
5. mixin 对象会被复制多份而不是共享的，把引入的 mixin 对象放入 data 中使用就是同一个对象会互相影响

# 第十四章 使用过渡和动画

1. transtion 元素只能给一个元素添加动画，一次放入多个元素会报错
2. 默认以 v-开头的类名

- -enter 在动画开始的一帧才添加到元素，下一帧就会被移除，一般用于设置初始状态
- -enter-active 直到动画结束才会被移除
- leave：离开时添加
- leave-active：整个离开过程

3. transition 的 type 属性可以用来规定使用 transition 的时间或者 animation 的时间
4. transition 的 appear 属性可以加上初始动画（第一次进入）,只有使用默认动画（默认 css 类）时才会生效
5. transition 存在 enter-calass 等属性可以覆盖默认的类名
6. 在 transition 中 v-show 取反不能同时存在
7. v-if 和 v-else 元素相同时 vue 只会替换内容不会替换元素，节省性能，可以添加 key 做区分
8. transition 的 mode 属性可以选择新旧元素的进出顺序
9. transition 钩子，done 函数告诉 vue 动画执行结束在 enter 和 leave 钩子内执行
10. 使用 css 属性设置为 false 用 js 接管动画
11. 动态组件也可以使用 transition 添加动画
12. transition-group 会渲染成一个 dom 标签，默认为 span 可以通过 tag 属性修改，而 transition 不会渲染到 dom，
13. transition-group 用法和 transition 一致，但是记得添加 key 值做区分，还有一个-move 类会被添加到需要改变位置的元素上

# 第十五章 vue-router

1. 路由默认 hash 模式，还有一个 history 模式可以在 VueRouter 实例里面设置
2. 使用 router-link 相当于在链接处监听了隐式的鼠标点击事件，点击之后不会执行默认操作而只是加载正确的路由
3. router-link 的 exact 属性要求链接完全匹配，默认模糊匹配
4. /：后面可以添加动态的部分,在 params 里面，是用这种方式绑定的值在变化之后组件不会重新加载，
5. $router是VueRouter实例，$route 是当前加载的路由
6. 组件在加载路由之后创建，所以在任何时候都可以访问\$route 对象
7. 监听\$route 对象可以拿到 vue-router 提供的 to 和 from 函数
8. 子路由路径为/时，路径会直接加到域名后面，不加/则表示加到父路由路径后
9. 给路由表配置 name 属性，在 router-link 的 to 中就可以绑定一个带 name 属性的对象进行跳转,name 加上 params 属性,也可以一起加上 query 属性
10. 命名路由视图：给 router-view 设置 name 属性，当前路由出口显示什么直接在路由表中设置 components，并用 key 对应出口的 name 即可
11. 路由加上#锚点可以跳到页面指定 id 位置
12. 传递 hash fragment,在路由中加入 hash 参数，在这之前要到 vue-router 实例中设置 scrollBehavior，接收三个参数 to，from，savedPosition,需要返回一个包含 x，y 坐标的对象
13. 路由守卫：三个可地方以检测用户进入路由；

- 第一个 main.js：beforeEach：每次路由跳转之前执行，参数是一个函数，函数接收 to，from，next,next 不传东西为正常跳转，传 false 终止在当前页，传路径跳转到指定页
- 第二个在 router 表中需要守卫的项加上 beforeEnter 函数，参数相同
- 第三个在需要加载的路由组件里设置 beforeRouteEnter，参数相同，如果不传 next 该组件就不会加载，也就访问不到 vue 实例，可以在 next 函数中加回调

14. beforeRouteLeave 是唯一检查用户离开的钩子
15. import 的组件就会加载，实现懒加载要在每个当中加载

# 第十六章 vuex

1. getters 是 vuex 的计算属性
2. mutations 是用来跟踪 vuex 状态改变的，每次使用都要 commit,并且只能执行同步代码
3. actions 异步的 mutations,使用 dispatch 触发
4. 避免一个 store 过于臃肿，使用 modules
