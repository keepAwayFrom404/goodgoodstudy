# 第二节 Vue 和 DOM 交互的基本方法

1. methods 当中的函数要返回一个可以转换为字符串的值才能在 html 模版里调用
2. 实例中的 this 可以访问 vue 实例当中定义的所有属性和方法
3. 在属性中使用双括号的模版语法双括号会被编码而无法解析，所以需要使用 v-bind
4. 指令是 vue 提供的一些指示
5. v-once 作用于 html 标签，使得内部的模版只会渲染一次
6. v-html 要谨慎使用，因为不知道用户提交的是什么内容，容易 XSS 攻击，只用来绑定自己生成的或者完全可靠的代码,或者拿到值之后进行输入检查
7. 事件 v-on 缩写后面的名字实际是传递给监听器的事件名参数
8. vue 事件会自动生成一个事件对象,可以通过第一个参数获取,当传递了其它参数可以通过传递\$event（不可改变）获得事件对象
9. 事件的 stop 修饰符可以阻止事件冒泡,prevent 阻止默认事件
10. keyup 键盘事件加上按键修饰符，可以多个
11. v-model 的本质是：（1）v-bind 绑定实例里面的值；（2）绑定输入事件当值变化时重新赋值
12. 计算属性里面所有的值都可以像 data 里面的值一样使用，使用计算属性只有内部的值变化才会重新计算，而使用 methods 每次点击都会触发模版语法中的事件
13. 计算属性只能执行同步代码，不能处理异步情况，watch 可以用来处理异步的情况
14. 回调函数不使用箭头函数 this 指向 window
15. class 绑定一个对象，key 为绑定的类名，如果类名包含中划线等字符需要使用单引号包起来，value 为一个布尔值，决定 key 的类名是否需要绑定；绑定多个类名可以使用计算属性 return 需要绑定的类对象；可以使用数组形式给 class 绑定多个表示类名的属性或者类名属性加混合对象来添加多个类名
16. style 绑定的也是一个 css 属性对象，也可以使用数组绑定混合样式
17. 小结：
    （1）最后一个题目没有自己的思路就直接开始乱写
    （2）取名字没有自己的规范，不够通熟易懂
    （3）代码偷懒

# 第三节 使用条件和列表渲染

1. template 标签在 html 中不会渲染，使用条件渲染可以将元素组合起来且不产生副作用
2. v-if 表示添加或者移除节点，v-show 是 css 隐藏（display：none），还存在与 dom 中,
3. v-for 除了可以遍历数组还可以遍历对象，index 为对象的 key 值而不是下标了，遍历对象下标在第三个参数

# 第五章 理解 vue 实例

1. 一个文件中可以共存多个 vue 实例，且他们之间互不影响，各自管理内部的属性和方法
2. vue 实例代理了内部属性内部的所有属性和方法，所以可以通过实例直接访问它们
3. 在实例的属性中有一个\$data 属性，等于 data 内部的属性对象
4. \$refs 不是响应式的，直接操作 dom 可能会被覆盖
5. \$mount 在没提供 el 时会创建一个未挂载的实例，文档将会被渲染为文档之外的元素，并且必须使用原生 DOM API 将它插入文档，返回实例本身，可以链式调用其他实例方法
6. 普通的 vue 实例不能当作组件的原因在于它只替换一个匹配到的元素，所以要注册组件
7. beforeCreate 生命周期在 new 实例创建之前执行，vue 会初始化构造方法传递的数据和事件，才创建 vue 实例；然后执行 created，之后 vue 会编译模版，根据 el 属性或者\$mount 方法从 HTML 代码内获取模版；beforeMount：挂载要渲染的模版之前调用，模版即将写入 DOM；然后将模版写入 DOM 触发 mounted

# 第六章 vue 命令进入真实开发

1. vue 文件编译后成为 js 可以插入到页面生成 dom

# 第八章 组件间通信

1. 父子组件传递对象或者数组等引用类型的数据时，实际传递的时指向内存地址的指针，改变会互相影响
2. \$emit 可以在子组件自定义事件，然后在父组件监听该事件并进行相应操作
3. event bus 是用来监听事件和传递数据的对象
4. 事件总线 eventbus 对象的注册应该在创建 vue 实例之前

# 第九章 深入组件

1. slot 的样式作用域是使用的地方而不是写的地方，而代码作用域是写的地方；样式在子组件设置，其他东西在在父组件处理
2. v-slot 指令只能使用在 template 元素上，而之前的 slot 可以用于任意元素
3. 绑定在 slot 上的特性被称为插槽 prop，可以给 v-slot 带一个值来定义我们提供插槽 prop 的名字；当只有默认插槽的时候 v-slot 可以用在组件上，不能混用
4. 作用域插槽的工作原理是将你的插槽内容包括在传入一个参数的函数当中，可以使用 v-slot：【动态名】来定义动态插槽名
5. 动态组件使用 component 标签 is 标识，里面可以插入内容会覆盖组件内容；动态组件之间切换会销毁重新创建；使用 keep-alive 可以保活
6. deactivated 在一个组件里载入另一个动态组件时调用（离开时）
7. activated：载入动态组件时调用

# 第十一章 用户表单输入处理

1. 给 v-model 绑定.lazy 修饰符会改变监听 input 而实际监听 change 事件；.trim 去除首尾空格；.number 将输入转成数字
2. 保留 textarea 文本的换行符可以使用样式 white-space：pre 保留
3. 给多个 input 类型为 checkbox 的元素绑定同一个变量，vue 会将它们自动整合到一个数组中；给多个 type 为 radio 绑定同一个值，会讲选中的值存入变量（存入的是 value 属性）
4. option 的 selected 属性可以绑定默认选项值（传入布尔值）；会被 v-model 绑定的默认值覆盖
5. prevent 修饰符可以阻止默认的 submit 事件
6. 不要再子组件修改父组件传递的 props 属性，会报错

# 第十二章 使用和创建指令

1. 指令下有五个钩子：

- bind：一旦指令完成绑定触发，三个参数：el 绑定的那个元素可以用来操作 dom；binding 是使用指令时的配置（参数。修饰符等）；vnode 虚拟 dom 中的节点（用的相对较少）
- inserted：成功插入父节点（仅保存父节点存在，不一定插入成功），但是可以直接操作，操作都会在插入之后表现出来，与 bind 参数一致
- update：一旦组件更新即调用，子组件尚未更新，多了一个 oldVnode 参数
- componentUpdate：一旦组件更新完，包括子组件
- unbind：指令移除时调用
- bind 和 update 是最常用的两个钩子
